<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Rat Rat</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Rat Rat"><meta name="msapplication-TileImage" content="/img/chord_logo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Rat Rat"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="rat rat"><meta property="og:type" content="blog"><meta property="og:title" content="Rat Rat"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Rat Rat"><meta property="og:description" content="rat rat"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Chord"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Rat Rat","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Chord"},"publisher":{"@type":"Organization","name":"Rat Rat","logo":{"@type":"ImageObject","url":"http://example.com/img/chord_logo.svg"}},"description":"rat rat"}</script><link rel="icon" href="/img/chord_logo.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/chord_logo.svg" alt="Rat Rat" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/categories/photo">photo</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item"><a class="link-muted" href="/categories/Photo/">Photo</a></span><span class="level-item">a few seconds read (About 22 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/11/20/Baobao/">饱的照片</a></p><div class="content"><p><img src="https://chord-pic.oss-cn-shanghai.aliyuncs.com/202411201927675.jpg" alt="DSCF7561"></p>
<p>测试自动部署</p>
<p>测试自动部署2</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item">a minute read (About 123 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/11/20/hello-world/">Hello World</a></p><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item"><a class="link-muted" href="/categories/Photo/">Photo</a></span><span class="level-item">a few seconds read (About 7 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/11/20/testImg/">TestPhoto</a></p><div class="content"><p><img src="http://oss.interviewguide.cn/img/202205220035271.png" alt="img"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item">an hour read (About 7438 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/11/20/C++%E5%85%AB%E8%82%A1%E6%96%87/">Hello World</a></p><div class="content"><h2 id="c-新特性"><a href="#c-新特性" class="headerlink" title="c++ 新特性"></a>c++ 新特性</h2><p>尾置返回值</p>
<p>std::optional</p>
<p>结构化绑定</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h4 id="RAII-是什么？"><a href="#RAII-是什么？" class="headerlink" title="RAII 是什么？"></a>RAII 是什么？</h4><p>resource acquire is initialization 资源获取即初始化</p>
<p>将资源和对象的生命周期绑定。</p>
<h4 id="hash-map-怎么实现"><a href="#hash-map-怎么实现" class="headerlink" title="hash map 怎么实现"></a>hash map 怎么实现</h4><p><img src="http://oss.interviewguide.cn/img/202205220035271.png" alt="img"></p>
<p>标准库用 vector 保存链表的头指针</p>
<p>什么时候 rehash ？ </p>
<p>超过最大负载因子</p>
<h4 id="vector-扩容机制"><a href="#vector-扩容机制" class="headerlink" title="vector 扩容机制"></a>vector 扩容机制</h4><p>两倍或者 1.5 倍。</p>
<p>均摊分析</p>
<h4 id="容器删除和迭代器"><a href="#容器删除和迭代器" class="headerlink" title="容器删除和迭代器"></a>容器删除和迭代器</h4><ul>
<li>顺序容器 (vector deque)<ul>
<li>erase 迭代器不仅会使该迭代器失效，还会使后面的迭代器都失效。</li>
<li>但是 erase 会返回下一个有效的迭代器。</li>
</ul>
</li>
<li>关联容器 (map, set, multimap, multiset)<ul>
<li>erase 迭代器只是让该迭代器失效。</li>
<li>erase 返回 void。</li>
<li>使用 earse(it++) 的方法删除迭代器。</li>
</ul>
</li>
</ul>
<h4 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h4><p>前向</p>
<ul>
<li>unordered_set &amp; unordered_map</li>
<li>forward_list</li>
</ul>
<p>双向</p>
<ul>
<li>list</li>
<li>set &#x2F; map</li>
</ul>
<p>随机访问</p>
<ul>
<li>deque</li>
<li>vector</li>
</ul>
<p><strong>输入迭代器</strong> InputIterator 支持逐个遍历和读取</p>
<p><strong>输出迭代器</strong> OutputIterator  支持逐个遍历和写入</p>
<h4 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h4><p>以 vector 为例</p>
<p>插入位置之后的迭代器失效。如果插入使得需要扩容时，所有迭代器失效。</p>
<p>删除位置之后的迭代器失效。</p>
<p>rehash 之后 unordered_map 的迭代器失效</p>
<h4 id="List-和-deque-的区别"><a href="#List-和-deque-的区别" class="headerlink" title="List 和 deque 的区别"></a>List 和 deque 的区别</h4><p>list 是一个双向环形链表</p>
<p>deque 是一个双向开口的连续线性空间</p>
<p>deque 和 vector</p>
<ul>
<li>deque 允许常数时间对头部和尾部插入或者移除</li>
<li>deque <strong>没有容量概念</strong>。动态地以分段连续空间组合而成。没有所谓的空间保留功能？</li>
<li>deque 支持随机访问</li>
</ul>
<p>空间配置器 allocator deallocator</p>
<p>两级配置器</p>
<p><img src="http://oss.interviewguide.cn/img/202205220035104.png" alt="img"></p>
<p><img src="https://img2022.cnblogs.com/blog/741401/202205/741401-20220504160717545-639927952.png" alt="img"></p>
<ul>
<li>第一级直接用 malloc， free 和 relloc</li>
<li>第二级若区块小于 128 bytes 使用内存池<ul>
<li>free_list 是一个以 8 为容量公差的长度为 16 的链表，最后一个节点区块为 128 bytes。</li>
<li>不足时调用 refill 申请 [1, 20] 块，并且将多的块放入 freelist</li>
<li>内存池一个 njob 空间都不够的时候，用 malloc 向 OS 申请内存<ul>
<li>申请不到，在后续的  freelist 里找</li>
<li>还是找不到，转到一级适配器，借助 oom 机制申请内存。</li>
</ul>
</li>
</ul>
</li>
<li>deallocate 先判断大小，若大于 128b 调用一级配置器，否则调用二级配置器。</li>
</ul>
<h4 id="std-deque-的实现"><a href="#std-deque-的实现" class="headerlink" title="std::deque 的实现"></a>std::deque 的实现</h4><p>问题：vector 头部操作的效率特别差</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//指向map指针的指针</span></span><br><span class="line">    map_pointer map;<span class="comment">//指向map</span></span><br><span class="line">    size_type map_size;<span class="comment">//map的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deque 迭代器维护连续的假象，迭代器需要知道:</span></span><br><span class="line"><span class="comment">// 1. 自己是不是在缓冲区边缘</span></span><br><span class="line"><span class="comment">// 2. 是不是在对头？上一个、下一个缓冲区在哪里？</span></span><br><span class="line"><span class="comment">// 3. 因此，deque 迭代器，需要保存：</span></span><br><span class="line"><span class="comment">// 		* first 缓冲区第一个元素		// 判断是不是第一个元素</span></span><br><span class="line"><span class="comment">// 		* last 缓冲区最后一个元素的后面		// 判断后面还有没有元素</span></span><br><span class="line"><span class="comment">// 		* 当前元素的指针</span></span><br><span class="line"><span class="comment">// 		* map_node 的指针</span></span><br><span class="line"><span class="comment">// 		* buffer_size 缓冲区能放的元素大小</span></span><br><span class="line"><span class="comment">// 迭代器存四个变量</span></span><br><span class="line"><span class="comment">// 一个是</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,...&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    T* cur;</span><br><span class="line">    T* first;</span><br><span class="line">    T* last;</span><br><span class="line">    map_pointer node;<span class="comment">//map_pointer 等价于 T**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h4 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h4><p>将函数标记为不会抛出异常，使用noexcept关键字标记的函数在它抛出异常时，编译器会直接调用名为”std::terminate”的方法，来<strong>中断</strong>程序的执行。</p>
<p>析构函数通常会被默认加上 noexcept</p>
<ul>
<li>希望析构直接完成</li>
<li>或者程序终止</li>
</ul>
<p>移动的时候加上 noexcept</p>
<ul>
<li>大多数容器调整大小用的<strong>不会抛出异常的移动构造</strong>，否则调用拷贝构造<ul>
<li>因为在资源的移动过程中如果抛出了异常，那么那些正在被处理的<strong>原始对象数据</strong>可能因为异常而丢失</li>
<li>拷贝的时候原始数据是安全的</li>
</ul>
</li>
</ul>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><p>指针是变量，存一个地址。引用是一个别名。</p>
<p>指针在传参的时候是值传递，引用是引用传递。</p>
<p>引用必须初始化，指针可以为空，也可以随便指向一个地址。</p>
<p>引用不可以再改变。引用不能为空。</p>
<p>递归的时候用引用可以降低开销。</p>
<h4 id="define-const-typedef-inline"><a href="#define-const-typedef-inline" class="headerlink" title="define const typedef inline"></a>define const typedef inline</h4><ol>
<li>define 只在预处理阶段起作用，没有类型检查。展开后占用的是代码段空间。</li>
<li>const 有类型。</li>
<li>typedef 有作用域限制，有类型检查</li>
<li>inline 是函数？再编译器替换。有类型检查。</li>
</ol>
<h4 id="explicit-隐式类型转换"><a href="#explicit-隐式类型转换" class="headerlink" title="explicit 隐式类型转换"></a>explicit 隐式类型转换</h4><p>构造函数前加上 explicit 可以防止构造函数的参数在传递的时候进行隐式类型转换。</p>
<p>支队一个实参的构造函数有用，因为需要多个实参的构造函数不能用于隐式类型转换，也就不用指定为 explicit 了。</p>
<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ol>
<li>大小、位置不同<ol>
<li>栈空间比较小，向低地址增长。申请的地址是固定的。</li>
<li>堆空间比较大，向高地址增长。申请的位置可以变化。</li>
</ol>
</li>
<li>申请和管理方式不同<ol>
<li>栈是系统自动分配的。自动回收。</li>
<li>堆要自己手动申请。由内存泄漏风险。</li>
</ol>
</li>
<li>申请效率不同<ol>
<li>栈由系统分配，快且没有碎片。</li>
<li>堆由程序员分配，慢且会有碎片。</li>
</ol>
</li>
<li><strong>取栈里的对象要快一些</strong>，因为<ol>
<li>寄存器里有栈地址</li>
<li>获取堆的内容要先读指针的内容，再读地址的内容。</li>
</ol>
</li>
</ol>
<h4 id="new-delete-与-malloc-free-的异同"><a href="#new-delete-与-malloc-free-的异同" class="headerlink" title="new &#x2F; delete 与 malloc &#x2F; free 的异同"></a>new &#x2F; delete 与 malloc &#x2F; free 的异同</h4><ul>
<li>前者是 C++ 的关键字，调用 new 运算符，后者是 C&#x2F;c++ 标准库函数。</li>
<li>前者自动算大小</li>
<li>前者会返回类型，是类型安全的。</li>
<li>前者会调用构造函数&#x2F;析构函数</li>
<li>前者可以重载</li>
</ul>
<p>new 会调用 operator new 申请空间，然后调用构造函数。</p>
<h5 id="重载operator-new"><a href="#重载operator-new" class="headerlink" title="重载operator new"></a>重载<code>operator new</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span>		<span class="comment">// 只要保证第一个参数是 size_t</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;placement new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Foo* m = <span class="keyword">new</span> Foo;</span><br><span class="line"> Foo* m2 = <span class="built_in">new</span>(m) Foo;	<span class="comment">// 使用的时候传一个参数给 new</span></span><br><span class="line"> std::cout &lt;&lt; <span class="built_in">sizeof</span>(m) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// delete m2;</span></span><br><span class="line"> <span class="keyword">delete</span> m;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用再内存池，不用重新申请空间，而是返回一个已经分配好空间的首地址。</p>
<h5 id="重载operator-delete"><a href="#重载operator-delete" class="headerlink" title="重载operator delete"></a>重载<code>operator delete</code></h5><p>一般不会重载 operator delete，原因是重载后的 operator delete <strong>不能手动调用</strong>。</p>
<p>这种重载的意义是<strong>和重载<code>operator new</code>配套</strong>。只有<code>operator new</code>报异常了，就会调用对应的<code>operator delete</code>。若没有对应的<code>operator delete</code>，则无法释放内存。</p>
<h4 id="不同类型的new"><a href="#不同类型的new" class="headerlink" title="不同类型的new"></a>不同类型的new</h4><ul>
<li><p>plain new</p>
<ul>
<li><pre><code class="c++">void* operator new(std::size_t) throw(std::bad_alloc); // 会抛出 std::bad_alloc
void operator delete(void *) throw();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* nothrow new</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    void * operator new(std::size_t,const std::nothrow_t&amp;) throw(); // 失败时不抛出异常而是返回 Null</span><br><span class="line">    void operator delete(void*) throw();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>placement new</p>
<ul>
<li><pre><code class="c++">void* operator new(size_t,void*);	// 不会分配内存，也就不会失败了
void operator delete(void*,void*);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### delete p、 delete [] p、 allocator 都有什么作用？</span><br><span class="line"></span><br><span class="line">* delete [] 时，数组中的元素按照逆序进行销毁。</span><br><span class="line">* delete p会调用一次析构函数，而delete[] p会**调用每个成员的析构函数**。</span><br><span class="line">* delete[] 时候会**向前找4个字节获取长度**，这4个字节是未定义的，所以调用了**不固定次数**的析构函数</span><br><span class="line">* allocator 将**内存分配和对象构造分开**，allocator 申请一部分内存，不进行初始化对象，只有需要的时候才会进行初始化操作。</span><br><span class="line"></span><br><span class="line">#### malloc 和 free 是怎么实现的？</span><br><span class="line"></span><br><span class="line">用系统调用 brk, mmap, munmap 这些系统调用实现。</span><br><span class="line"></span><br><span class="line">* brk 是堆顶指针向高地址移动</span><br><span class="line">* mmap 是在进程的虚拟空间中（文件映射区）找一快空闲的虚拟内存。</span><br><span class="line">* 在第一次访问的时候，发生**缺页中断**，操作系统负责分配物理内存，然后简历虚拟内存和物理内存之间的映射关系。</span><br><span class="line">* malloc**大于128k的内存**，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，</span><br><span class="line">* brk 分配的内存要等到高地址内存释放后才能释放，mmap可以单独释放。当高地址空间的空闲内存高于 128 k 执行内存紧缩。</span><br><span class="line">* 操作系统有一个记录**空闲地址的链表**，当操作系统收到程序的申请就会遍历链表找到第一个大于申请空间的节点，然后删除这个节点。</span><br><span class="line"></span><br><span class="line">brk 找K线链表的策略：</span><br><span class="line"></span><br><span class="line">* 最优匹配：找到 &gt;= M 的最小的节点</span><br><span class="line">* 最差匹配：找到 &gt;= M 的最大的节点</span><br><span class="line">* 首次匹配</span><br><span class="line">* 下次匹配</span><br><span class="line"></span><br><span class="line">除了空闲链表的其他空闲内存方式：</span><br><span class="line"></span><br><span class="line">* 分离分散链表：每一种大小的空间简历独立的链表</span><br><span class="line"></span><br><span class="line">* **伙伴系统**：空闲空间递归一分为二直到满足。伙伴系统的伙伴只有1位不同，比较好找。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### malloc realloc calloc</span><br><span class="line"></span><br><span class="line">* realloc 用于扩容</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void* malloc(unsigned int num_size);</span><br><span class="line">int *p = malloc(20*sizeof(int)); // 申请20个int类型的空间；</span><br><span class="line"></span><br><span class="line">void* calloc(size_t n,size_t size);</span><br><span class="line">int *p = calloc(20, sizeof(int)); 	 // 省去计算，并且初始化为 0  </span><br><span class="line"></span><br><span class="line">void realloc(void *p, size_t new_size); // 接收一个指针，在其后扩容。主要用于动态扩容。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="顶层const-底层const"><a href="#顶层const-底层const" class="headerlink" title="顶层const 底层const"></a>顶层const 底层const</h4><p>顶层 const 修饰的<strong>变量本身</strong>是一个常量</p>
<p>底层 const 指的是 const 修饰的变量<strong>指向的对象</strong>是一个常量</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>禁止继承</p>
<p>禁止重写，C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面，如下</p>
<h4 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h4><ul>
<li>野指针：没有被初始化的指针 &#x3D;&#x3D;》 初始化</li>
<li>悬空指针：指针最初指向的内存被释放了  &#x3D;&#x3D;》 释放后立即置空</li>
</ul>
<h4 id="重载重写和隐藏"><a href="#重载重写和隐藏" class="headerlink" title="重载重写和隐藏"></a>重载重写和隐藏</h4><ul>
<li>重载 overload<ul>
<li>同名函数，参数不同</li>
</ul>
</li>
<li>重写 override<ul>
<li>派生类覆盖基类的同名函数</li>
<li>相同的参数个数、参数类型和返回值类型</li>
</ul>
</li>
<li>隐藏<ul>
<li>派生类的函数屏蔽了基类的同名函数（可以用：：访问被隐藏的函数）</li>
<li>参数相同，但是基类函数不是虚函数</li>
<li><strong>参数不同，无论基类函数是不是虚函数都会被隐藏</strong></li>
</ul>
</li>
</ul>
<h4 id="构造函数的类别"><a href="#构造函数的类别" class="headerlink" title="构造函数的类别"></a>构造函数的类别</h4><ul>
<li><p>默认构造函数</p>
</li>
<li><p>初始化构造函数</p>
</li>
<li><p>拷贝构造函数</p>
<ul>
<li><pre><code class="c++">Student (const Student&amp;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 移动构造函数</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    Student (Student&amp;&amp;);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>委托构造函数</p>
<ul>
<li>被委托的构造函数在委托构造函数的初始化列表里被调用，而不是在委托构造函数的函数体里被调用。</li>
</ul>
</li>
<li><p>转换构造函数</p>
<ul>
<li>只有一个其他类型的形参</li>
</ul>
</li>
</ul>
<h4 id="类成员初始化？构造函数顺序？初始化列表为什么快？"><a href="#类成员初始化？构造函数顺序？初始化列表为什么快？" class="headerlink" title="类成员初始化？构造函数顺序？初始化列表为什么快？"></a>类成员初始化？构造函数顺序？初始化列表为什么快？</h4><ul>
<li><p>赋值初始化(在{}里初始化) 是先分配内存空间才初始化。</p>
</li>
<li><p>列表初始化时给数据成员分配空间的时候就初始化。初始化的时候函数体还没执行</p>
</li>
</ul>
<p>派生类构造函数的执行顺序</p>
<ol>
<li>虚基类</li>
<li>基类</li>
<li>类类型成员的构造函数</li>
<li>自己的构造函数</li>
</ol>
<p>前者是构造函数里赋值，后者是纯粹的初始化操作。赋值操作有时候会产生临时对象。</p>
<h4 id="什么时候必须成员列表初始化？作用是什么？"><a href="#什么时候必须成员列表初始化？作用是什么？" class="headerlink" title="什么时候必须成员列表初始化？作用是什么？"></a>什么时候必须成员列表初始化？作用是什么？</h4><p>其实就是什么时候不能用赋值初始化。</p>
<ol>
<li>引用成员</li>
<li>常量成员</li>
<li>基类带参数的构造函数</li>
<li>类成员的带参数的构造函数</li>
</ol>
<p>列表初始化实际上：</p>
<ol>
<li>编译器在构造函数内安插初始化操作。</li>
<li>初始化顺序和声明顺序相关。</li>
</ol>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ul>
<li>浅拷贝：只拷贝一个指针，不开辟新的地址</li>
<li>深拷贝：拷贝指针值，并且开辟出新的空间</li>
</ul>
<h4 id="大端和小端"><a href="#大端和小端" class="headerlink" title="大端和小端"></a>大端和小端</h4><ul>
<li>大端：高字节在低地址</li>
<li>小端：低字节在低地址</li>
</ul>
<h4 id="volatile-mutable-explicit"><a href="#volatile-mutable-explicit" class="headerlink" title="volatile mutable explicit"></a>volatile mutable explicit</h4><ul>
<li><p>volatile</p>
<p>用 volatile 修饰的变量总是需要重新从地址读数据。</p>
<ul>
<li>表示变量<strong>可以被编译器未知因素更改</strong>（OS, Thread, hardware）</li>
<li>编译器对访问该变量的代码不在进行优化</li>
<li>总是重新从它所在的地址读取数据</li>
<li><strong>防止编译器把值放入寄存器</strong></li>
</ul>
</li>
<li><p>mutable</p>
<ul>
<li>意思是可变的，和 const 是反义词</li>
<li>有些时候可能想在 const 函数里修改一些跟状态无关的数据成员</li>
</ul>
</li>
<li><p>explicit</p>
<ul>
<li>不能发生隐式类型转换</li>
<li>只能加在构造函数声明上</li>
<li>被 explicit 修饰的构造函数的类不能发生隐式类型转换</li>
</ul>
</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="try-throw-catch"><a href="#try-throw-catch" class="headerlink" title="try throw catch"></a>try throw catch</h4><ul>
<li><p>catch(…) 可以捕获任何异常</p>
</li>
<li><p>catch 的异常不想在本函数处理，可以在 catch 里抛出异常。</p>
</li>
<li><p>异常声明：</p>
<ul>
<li><pre><code class="c++">int fun() throw(int,double,A,B,C)&#123;...&#125;; // throw 里声明能抛出的异常的列表
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 标准异常 exception</span><br><span class="line"></span><br><span class="line">  * std::bad_typeid</span><br><span class="line">  * std::bad_cast</span><br><span class="line">  * std::bad_alloc</span><br><span class="line">  * ...</span><br><span class="line">  * ![C++ 异常的层次结构](https://www.runoob.com/wp-content/uploads/2015/05/exceptions_in_cpp.png)</span><br><span class="line">  * 自定义异常</span><br><span class="line">    * 方法：继承和重载 excepption 类</span><br><span class="line"></span><br><span class="line">#### static</span><br><span class="line"></span><br><span class="line">1. 隐藏在文件作用域</span><br><span class="line">   1. 函数默认是 extern 声明的</span><br><span class="line">   2. 定义静态函数可以在其他文件定义同名函数，并且不会被其他文件引用</span><br><span class="line">2. 保持内容的持久，存储在静态存储区</span><br><span class="line">3. **static 类对象必须在类外初始化**</span><br><span class="line">   1. static 修饰的对象先于对象存在，因此要在类外初始化</span><br><span class="line">4. static 对象不属于任何对象或者实例</span><br><span class="line">   1. 因此不能被 virtual 修饰</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### main 函数之前做了什么事情？</span><br><span class="line"></span><br><span class="line">* 设置栈指针</span><br><span class="line">* 初始化 static 对象和 global 对象，也就是 .data 段的内容</span><br><span class="line">* 将未初始化的全局变量赋予初值</span><br><span class="line">* 全局对象初始化，也就是调用构造函数。（可以注入一些代码在 main 之前执行）</span><br><span class="line">* 将 main 函数的参数 argc， argv 传递给 main 函数。</span><br><span class="line"></span><br><span class="line">#### main 函数执行完之后呢？</span><br><span class="line"></span><br><span class="line">* **全局对象的析构**</span><br><span class="line"></span><br><span class="line">#### 野指针 悬空指针</span><br><span class="line"></span><br><span class="line">野指针指向未知的区域</span><br><span class="line"></span><br><span class="line">* 指针没有初始化</span><br><span class="line"></span><br><span class="line">悬空指针</span><br><span class="line"></span><br><span class="line">* 指针指向的内容已经被释放了。</span><br><span class="line">* 或者声明周期已经结束了。</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">* 初始化</span><br><span class="line">* 用指针的时候判断是不是空的</span><br><span class="line">* 释放之后指针置为 nullptr</span><br><span class="line">* 使用智能指针</span><br><span class="line"></span><br><span class="line">#### 什么是内存泄漏</span><br><span class="line"></span><br><span class="line">内存泄漏：分配的内存没有释放，导致这块内存不能被再次使用。</span><br><span class="line"></span><br><span class="line">原因：</span><br><span class="line"></span><br><span class="line">* new 了**没有 delete** 或者**没有 delete []**。</span><br><span class="line">* 析构函数没有释放内存。</span><br><span class="line">* 没有将**基类的析构函数没有声明为虚函数**</span><br><span class="line">  * 否则 delete 派生类的基类指针的时候**派生类的析构函数被覆盖**不能正常析构。</span><br><span class="line"></span><br><span class="line">&gt; 《Effective C++》中的观点是，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数。</span><br><span class="line"></span><br><span class="line">* 有指针成员，但是**没有自己的拷贝构造函数 / 重载赋值运算符**。</span><br><span class="line">* 返回值为野指针。</span><br><span class="line">* 循环引用。</span><br><span class="line"></span><br><span class="line">避免内存泄漏的方法：</span><br><span class="line"></span><br><span class="line">* 引用计数法 类似于智能指针</span><br><span class="line">* 在构造的时候 new，析构的时候 delete</span><br><span class="line">* **将基类的虚函数声明为虚函数**</span><br><span class="line">* 对象数组的释放用 **delete []** 也就是 new new[] delete delete[]配套</span><br><span class="line">* 有 new 就别忘了 delete</span><br><span class="line"></span><br><span class="line">检测工具</span><br><span class="line"></span><br><span class="line">* Valgrind</span><br><span class="line">* Asam</span><br><span class="line"></span><br><span class="line">#### 面向对象三大特性</span><br><span class="line"></span><br><span class="line">继承多态和封装</span><br><span class="line"></span><br><span class="line">多态的方式：</span><br><span class="line"></span><br><span class="line">* 覆盖：子类重写父类的虚函数。// 运行时多态</span><br><span class="line">* 重载：允许同名函数，不同参数。// 编译时多态</span><br><span class="line">* 模板，模板特化</span><br><span class="line"></span><br><span class="line">#### 四种强制类型转换</span><br><span class="line"></span><br><span class="line">上行转换：派生变基类：安全</span><br><span class="line"></span><br><span class="line">下行转换：基类变派生：不安全</span><br><span class="line"></span><br><span class="line">* reinterpret_cast&lt;typeid&gt; (exp)</span><br><span class="line">  * 直接转</span><br><span class="line">* const_cast&lt;typeid&gt; (exp)</span><br><span class="line">  * 修改类型的 const 或者 volatile 属性</span><br><span class="line">* static_cast&lt;typeid&gt; (exp)</span><br><span class="line">  * **没有类型检查**，用于基类和派生类之间的转换</span><br><span class="line">    * 上行 把派生类指针/引用换成基类的 ： 安全</span><br><span class="line">    * 下行 把基类的指针/引用换成派生类 ： 不安全</span><br><span class="line">  * 用于基本类型的转换</span><br><span class="line">  * 空指针换成其他类型指针</span><br><span class="line">* dynamic_cast&lt;typeid&gt; (exp)</span><br><span class="line">  * **有类型检查**，基类向派生类转换比较安全</span><br><span class="line">  * 在执行期的时候决定真正的类型。</span><br><span class="line">  * 上行转换和 static_cast 一样</span><br><span class="line">  * 下行转换时 dynamic_cast 有类型检查的功能</span><br><span class="line">    * **dynamic_cast 会给出 nullptr**</span><br><span class="line">    * **而 static_cast 会给出未定义！**</span><br><span class="line"></span><br><span class="line">#### 不使用额外空间交换两数。</span><br><span class="line"></span><br><span class="line">1. ```c++</span><br><span class="line">   x = x + y;</span><br><span class="line">   y = x - y;</span><br><span class="line">   x = x - y;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><pre><code class="c++">x = x ^ y;
y = x ^ y;
x = x ^ y;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### strcpy 和 memcpy 的区别</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">// 该函数返回一个指向最终的目标字符串 dest 的指针。</span><br><span class="line">char *strcpy(char *dest, const char *src);</span><br><span class="line"></span><br><span class="line">// 该函数返回一个指向目标存储区 str1 的指针。</span><br><span class="line">void *memcpy(void *str1, const void *str2, size_t n);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>strcpy 复制字符擦混</p>
</li>
<li><p>memcpy 复制任何内容</p>
</li>
<li><p>strcpy不用指定长度 ‘\0’</p>
</li>
<li><p>memcpy 要指定长度</p>
</li>
</ol>
<h4 id="编译器的默认函数"><a href="#编译器的默认函数" class="headerlink" title="编译器的默认函数"></a>编译器的默认函数</h4><ul>
<li>默认缺省构造函数</li>
<li>默认拷贝构造函数</li>
<li>默认析构函数</li>
<li>默认赋值运算符</li>
<li>…. 默认移动构造 默认移动赋值？</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li>输入迭代器</li>
<li>输出迭代器</li>
<li>前向迭代器</li>
<li>双向迭代器</li>
<li>随机访问迭代器</li>
</ul>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p>虚继承可以解决菱形继承的问题。不用复制多份基类。</p>
<ul>
<li>bptr 虚继承的子类指向父类的指针&#x2F;偏移量，可能会和 vptr 合并。</li>
</ul>
<p>链继承 C : B : A</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                                                      C VTable（不完整)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>                                              +------------+</span><br><span class="line">object                                                | RTTI <span class="keyword">for</span> C |</span><br><span class="line">    <span class="number">0</span> - <span class="keyword">struct</span> <span class="title class_">B</span>                            +-------&gt; +------------+</span><br><span class="line">    <span class="number">0</span> -   <span class="keyword">struct</span> <span class="title class_">A</span>                          |         |   C::<span class="built_in">f0</span>()  |</span><br><span class="line">    <span class="number">0</span> -     vptr_A -------------------------+         +------------+</span><br><span class="line">    <span class="number">8</span> -     <span class="type">int</span> ax                                    |   B::<span class="built_in">f1</span>()  |</span><br><span class="line">   <span class="number">12</span> -   <span class="type">int</span> bx                                      +------------+</span><br><span class="line">   <span class="number">16</span> - <span class="type">int</span> cx                                        |   C::<span class="built_in">f2</span>()  |</span><br><span class="line"><span class="built_in">sizeof</span>(C): <span class="number">24</span>    align: <span class="number">8</span>                             +------------+</span><br></pre></td></tr></table></figure>

<p>多继承</p>
<p>C : A, B</p>
<ul>
<li><p>一个物理虚函数表，两个虚函数表指针和两个逻辑虚函数表。</p>
</li>
<li><p>需要保存一个到虚函数顶部的 offset_to_top</p>
<ul>
<li>在多继承中，由于<strong>不同的基类起点可能处于不同的位置</strong>，因此当需要将它们转化为实际类型时，**<code>this</code>指针的偏移量也不相同<strong>。由于实际类型在编译时是未知的，这要求</strong>偏移量必须能够在运行时获取**。</li>
<li>实体<code>offset_to_top</code>表示的就是实际类型起始地址到当前这个形式类型起始地址的偏移量。在向上动态转换到实际类型时，让**<code>this</code>指针加上这个偏移量**即可得到实际类型的地址。</li>
</ul>
</li>
<li><p>thunk: 解决子类 this 指针偏移问题</p>
<ul>
<li>为了弄清楚<code>Thunk</code>是什么，我们首先要注意到，如果一个类型<code>B</code> 的引用持有了实际类型为<code>C</code>的变量，这个引用的起始地址在<code>C+16</code>处。当它调用由类型<code>C</code>重写的函数<code>f1()</code>时，如果直接使用<code>this</code>指针调用<code>C::f1()</code>会由于<code>this</code>指针的地址多出<code>16</code>字节的偏移量导致错误。 因此在调用之前，<code>this</code>指针必须要被调整至正确的位置 。这里的<code>Thunk</code>起到的就是这个作用：**首先将<code>this</code> 指针调整到正确的位置，即减少<code>16</code>字节偏移量，然后再去调用函数<code>C::f1()</code>**。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                                                <span class="function">C <span class="title">Vtable</span> <span class="params">(<span class="number">7</span> entities)</span></span></span><br><span class="line"><span class="function">                                                +--------------------+</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> C                                        | <span class="title">offset_to_top</span> <span class="params">(<span class="number">0</span>)</span>  |</span></span><br><span class="line"><span class="function">object                                          +--------------------+</span></span><br><span class="line"><span class="function">    0 - <span class="keyword">struct</span> <span class="title">A</span> <span class="params">(primary base)</span>                 |     RTTI <span class="keyword">for</span> C     |</span></span><br><span class="line"><span class="function">    0 -   vptr_A -----------------------------&gt; +--------------------+       </span></span><br><span class="line"><span class="function">    8 -   <span class="type">int</span> ax                                |       <span class="title">C::f0</span><span class="params">()</span>      |</span></span><br><span class="line"><span class="function">   16 - <span class="keyword">struct</span> B                                +--------------------+</span></span><br><span class="line"><span class="function">   16 -   vptr_B ----------------------+        |       <span class="title">C::f1</span><span class="params">()</span>      |</span></span><br><span class="line"><span class="function">   24 -   <span class="type">int</span> bx                       |        +--------------------+</span></span><br><span class="line"><span class="function">   28 - <span class="type">int</span> cx                         |        | <span class="title">offset_to_top</span> <span class="params">(<span class="number">-16</span>)</span>|</span></span><br><span class="line"><span class="function"><span class="title">sizeof</span><span class="params">(C)</span>: <span class="number">32</span>    align: <span class="number">8</span>              |        +--------------------+</span></span><br><span class="line"><span class="function">                                       |        |     RTTI for C     |</span></span><br><span class="line"><span class="function">                                       +------&gt; +--------------------+</span></span><br><span class="line"><span class="function">                                                |    Thunk C::f1()   |</span></span><br><span class="line"><span class="function">                                                +--------------------+</span></span><br></pre></td></tr></table></figure>



<p>虚继承</p>
<p><strong>虚基类只存一次！子类存到虚基类的虚函数表的指针</strong></p>
<p>不使用虚继承，基类存多份</p>
<img src="C:\Users\19183\AppData\Roaming\Typora\typora-user-images\image-20241008234528644.png" alt="image-20241008234528644" style="zoom:50%;" />

<p>使用菱形继承，基类只存一份</p>
<img src="C:\Users\19183\AppData\Roaming\Typora\typora-user-images\image-20241008235152183.png" alt="image-20241008235152183" style="zoom:50%;" />

<p>B:A; C:A, D: B, C</p>
<ul>
<li><strong>虚基类偏移量</strong> &#x2F; <strong>虚基类指针</strong>？ （<strong>和编译器有关！</strong>可以是存在线性地址里，通过偏移量确定（g++），也可以开辟新的<strong>虚基表</strong>指针，指向虚基类的地址（vs））</li>
<li><strong>虚基类由最后的子类实现</strong><ul>
<li>所以在最后的位置</li>
<li>虚基类中被子类重写的函数需要指向 vcall_offset<ul>
<li>因为运行时才知道虚基类的 this 指针的位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">                                          D VTable</span><br><span class="line">                                          +---------------------+</span><br><span class="line">                                          |   vbase_offset(32)  |</span><br><span class="line">                                          +---------------------+</span><br><span class="line">struct D                                  |   offset_to_top(0)  |</span><br><span class="line">object                                    +---------------------+</span><br><span class="line">    0 - struct B (primary base)           |      RTTI for D     |</span><br><span class="line">    0 -   vptr_B  ----------------------&gt; +---------------------+</span><br><span class="line">    8 -   int bx                          |       D::f0()       |</span><br><span class="line">   16 - struct C                          +---------------------+</span><br><span class="line">   16 -   vptr_C  ------------------+     |   vbase_offset(16)  |</span><br><span class="line">   24 -   int cx                    |     +---------------------+</span><br><span class="line">   28 - int dx                      |     |  offset_to_top(-16) |</span><br><span class="line">   32 - struct A (virtual base)     |     +---------------------+</span><br><span class="line">   32 -   vptr_A --------------+    |     |      RTTI for D     |</span><br><span class="line">   40 -   int ax               |    +---&gt; +---------------------+</span><br><span class="line">sizeof(D): 48    align: 8      |          |       D::f0()       |</span><br><span class="line">                               |          +---------------------+</span><br><span class="line">                               |          |   vcall_offset(0)   |x--------+</span><br><span class="line">                               |          +---------------------+         |</span><br><span class="line">                               |          |   vcall_offset(-32) |o----+   |</span><br><span class="line">                               |          +---------------------+     |   |</span><br><span class="line">                               |          |  offset_to_top(-32) |     |   |</span><br><span class="line">                               |          +---------------------+     |   |</span><br><span class="line">                               |          |      RTTI for D     |     |   |</span><br><span class="line">                               +--------&gt; +---------------------+     |   |</span><br><span class="line">                                          |     Thunk D::f0()   |o----+   |</span><br><span class="line">                                          +---------------------+         |</span><br><span class="line">                                          |       A::bar()      |x--------+</span><br><span class="line">                                          +---------------------+     </span><br></pre></td></tr></table></figure>

<p><strong>虚基类位于派生类存储空间的末尾。</strong></p>
<h4 id="虚函数指针和虚函数表的创建时机："><a href="#虚函数指针和虚函数表的创建时机：" class="headerlink" title="虚函数指针和虚函数表的创建时机："></a>虚函数指针和虚函数表的创建时机：</h4><p>虚函数表是在编译的过程创建</p>
<p>虚函数指针在运行时创建</p>
<h4 id="构造函数、析构函数、虚函数能不能是内联函数？"><a href="#构造函数、析构函数、虚函数能不能是内联函数？" class="headerlink" title="构造函数、析构函数、虚函数能不能是内联函数？"></a>构造函数、析构函数、虚函数能不能是内联函数？</h4><ul>
<li><p>inline 只是个建议，所以语法上没有错误。</p>
</li>
<li><p>effective C++ 里阐述：编译器不会真正的对 inline 的构造和析构函数进行内联操作，因为编译器要在构造和析构函数中添加额外的操作。（申请&#x2F;释放内存，构造&#x2F;析构对象）。实际上构造函数&#x2F;析构函数要比看起来复杂。</p>
</li>
<li><p><strong>对于虚函数，要分情况。</strong></p>
<ul>
<li>如果虚函数能在编译期就决定调用哪个函数，就可以进行内联。</li>
<li><strong>在对象里调用虚虚函数。</strong></li>
</ul>
</li>
</ul>
<h4 id="构造函数为什么不能是虚函数？析构函数为什么是虚函数？"><a href="#构造函数为什么不能是虚函数？析构函数为什么是虚函数？" class="headerlink" title="构造函数为什么不能是虚函数？析构函数为什么是虚函数？"></a>构造函数为什么不能是虚函数？析构函数为什么是虚函数？</h4><ul>
<li>构造函数<ul>
<li>存储上，没有实例化就没有vtable。调用构造函数的时候不能确定真实的类型。所以 ctor 不能是虚函数。</li>
<li>构造函数只在初始化时运行一次，不是动态行为，没必要多态。</li>
<li>构造函数第一件事就是初始化 vptr。</li>
</ul>
</li>
<li>析构函数<ul>
<li>是为了防止内存泄漏。</li>
<li>如果析构函数不是虚函数，就不能正确识别对象类型从而正确调用析构函数。如果不把析构函数弄成虚函数，基类指针指向派生类的时候就不会发生动态绑定。</li>
</ul>
</li>
</ul>
<h4 id="多个构造函数、析构函数顺序"><a href="#多个构造函数、析构函数顺序" class="headerlink" title="多个构造函数、析构函数顺序"></a>多个构造函数、析构函数顺序</h4><ul>
<li>构造函数<ul>
<li>基类构造函数，多个基类按照派生表中的顺序</li>
<li>成员类构造函数，按照声明顺序</li>
<li>派生类构造函数</li>
</ul>
</li>
<li>析构函数<ul>
<li>派生类的虚构函数</li>
<li>成员类的析构函数</li>
<li>基类的析构函数</li>
</ul>
</li>
</ul>
<h4 id="构造函数内部执行顺序"><a href="#构造函数内部执行顺序" class="headerlink" title="构造函数内部执行顺序"></a>构造函数内部执行顺序</h4><ol>
<li>基类&#x2F;虚基类构造</li>
<li>vptr 初始化</li>
<li>扩展成员初始化列表</li>
<li>执行程序员代码</li>
</ol>
<h4 id="哪些函数不能是虚函数？"><a href="#哪些函数不能是虚函数？" class="headerlink" title="哪些函数不能是虚函数？"></a>哪些函数不能是虚函数？</h4><ol>
<li><strong>构造</strong>函数</li>
<li><strong>静态</strong>函数</li>
<li>友元函数</li>
<li><strong>普通</strong>函数</li>
<li><strong>内联</strong>函数</li>
</ol>
<h4 id="模板类要写在一个文件里面"><a href="#模板类要写在一个文件里面" class="headerlink" title="模板类要写在一个文件里面"></a>模板类要写在一个文件里面</h4><p>因为编译的时候模板不会生成真正的代码。实例化模板只能找到声明，链接器找不到链接程序会报错。</p>
<h2 id="c-内存管理"><a href="#c-内存管理" class="headerlink" title="c++ 内存管理"></a>c++ 内存管理</h2><h4 id="类空间有什么"><a href="#类空间有什么" class="headerlink" title="类空间有什么"></a>类空间有什么</h4><ol>
<li>非静态成员</li>
<li>虚函数表指针</li>
<li>padding</li>
<li>空类 size 为1</li>
</ol>
<h4 id="C-内存分区"><a href="#C-内存分区" class="headerlink" title="C++内存分区"></a>C++内存分区</h4><p>栈</p>
<p>堆</p>
<p>全局数据</p>
<p>常量</p>
<p>代码段</p>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><ol>
<li>try throw catch</li>
</ol>
<h4 id="COREDUMP"><a href="#COREDUMP" class="headerlink" title="COREDUMP"></a>COREDUMP</h4><p><a target="_blank" rel="noopener" href="http://sunyongfeng.com/201609/programmer/tools/coredump">http://sunyongfeng.com/201609/programmer/tools/coredump</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c // 查看当前core 大小限制</span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited // 解除限制</span><br><span class="line"><span class="built_in">cat</span> /etc/security/limits.conf // 查看限制</span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/core_pattern // 查看 core pattern </span><br><span class="line">// %t 时间戳</span><br><span class="line">// %e 程序名</span><br><span class="line">// %s 信号</span><br><span class="line">// %p 进程号</span><br><span class="line"></span><br><span class="line">// GDB 调试 coredump </span><br><span class="line">gdb a.out core-a.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>bt 查看调用栈</p>
</li>
<li><p>f n 查看某个栈帧</p>
</li>
<li><p>info</p>
<ul>
<li>info frame</li>
<li>info registers</li>
<li>info args</li>
<li>info locals</li>
<li>info threads 查看线程</li>
</ul>
</li>
</ul>
<h2 id="编译连接"><a href="#编译连接" class="headerlink" title="编译连接"></a>编译连接</h2><ul>
<li><p>预处理 g++ <strong>-E</strong> main.cpp -o <strong>main.i</strong></p>
<ul>
<li>删除注释</li>
<li>引入头文件 #pragma once once</li>
<li>宏展开</li>
</ul>
</li>
<li><p>编译 g++ <strong>-S</strong> main.i -o <strong>main.s</strong></p>
<ul>
<li>代码优化 指令重排？</li>
<li>汇总所有的符号<ul>
<li>函数名修饰 (重载)</li>
</ul>
</li>
</ul>
</li>
<li><p>汇编 二进制可重定位文件 <strong>main.o</strong> 每个都有 text data bss heap 内核段，需要合并（链接）</p>
<ul>
<li>为什么合并？1. 浪费空间 2. 空间局部性不好</li>
<li>汇编编程机器码</li>
</ul>
</li>
<li><p>链接 可执行文件</p>
<ul>
<li><strong>合并所有的 obj 文件的段</strong>，<strong>调整段的偏移和段长度</strong>，<strong>合并符号表</strong></li>
<li>地址与空间分配</li>
<li>符号解析与重定位</li>
</ul>
</li>
</ul>
<p><code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间</p>
<p>TODO</p>
<h4 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h4><ul>
<li>静态链接<ul>
<li>符号解析</li>
<li>重定位<ul>
<li>作用：为了生成位置无关代码。这样共享库就可以放在任意的位置了。</li>
<li>相对重定位条目<ul>
<li>PC + 偏移量</li>
</ul>
</li>
<li>绝对重定位条目<ul>
<li>绝对地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>动态链接<ul>
<li>为了解决静态库的问题<ul>
<li>静态库更新程序需要重新链接</li>
<li>共享代码节约资源</li>
</ul>
</li>
<li>一个库只有一个文件</li>
<li>在内存中共享库的 .text 节可以被共享</li>
<li>需要一个动态链接器</li>
<li><img src="http://oss.interviewguide.cn/img/202205212343182.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="动态编译和静态编译"><a href="#动态编译和静态编译" class="headerlink" title="动态编译和静态编译"></a>动态编译和静态编译</h4><ul>
<li>静态编译和动态编译是两种不同的编译方式，用于生成可执行文件。让我为您详细解释一下：<ol>
<li><strong>静态编译</strong>：<ul>
<li>在静态编译时，编译器将程序<strong>与其所有依赖项（包括库）链接在一起</strong>，形成一个单独的可执行文件。</li>
<li>这个可执行文件包含了所有代码和数据，因此它是一个完全独立的二进制文件。</li>
<li>静态编译的优点是可执行文件<strong>不依赖于外部动态链接库</strong>，因此在运行时不需要加载其他库文件。</li>
<li>缺点是可执行文件体积较大，且编译速度较慢。</li>
</ul>
</li>
<li><strong>动态编译</strong>：<ul>
<li>在动态编译时，只创建程序的框架，而不将所有依赖项包含在可执行文件中。</li>
<li>动态编译的<strong>可执行文件需要附带一个动态链接库</strong>，在执行时，需要调用其对应动态链接库中的命令。</li>
<li>优点是<strong>缩小了可执行文件本身的体积，加快了编译速度</strong>，节省了系统资源。</li>
<li>缺点是需要安装对应的运行库，否则无法运行动态编译的可执行文件。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="并发编程相关"><a href="#并发编程相关" class="headerlink" title="并发编程相关"></a>并发编程相关</h4><h3 id="C-的锁"><a href="#C-的锁" class="headerlink" title="C++ 的锁"></a>C++ 的锁</h3><ul>
<li>读写锁</li>
<li>互斥锁<ul>
<li>互斥机制</li>
</ul>
</li>
<li>条件变量<ul>
<li>一种同步机制</li>
</ul>
</li>
<li>自旋锁</li>
</ul>
<h2 id="智能指针相关"><a href="#智能指针相关" class="headerlink" title="智能指针相关"></a>智能指针相关</h2><h4 id="1-enable-shared-from-this"><a href="#1-enable-shared-from-this" class="headerlink" title="1. enable_shared_from_this"></a>1. enable_shared_from_this</h4><p>允许一个类继承自它，以便获得指向 <code>this</code> 的 <code>shared_ptr</code> </p>
<p>用处：异步回调，事件处理，观察者模式</p>
<p><strong>实现方法</strong></p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><ul>
<li>weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，<strong>没有重载<code>operator*</code>和<code>-&gt;</code></strong>,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。</li>
<li>weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</li>
<li>使用weak_ptr的成员函数<code>use_count()</code>可以观测资源的引用计数，另一个成员函数<code>expired()</code>的功能等价于<code>use_count()==0</code>,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</li>
<li>weak_ptr可以使用一个非常重要的成员函数<code>lock()</code>从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当<code>expired()==true</code>的时候，<code>lock()</code>函数将返回一个存储空指针的shared_ptr。</li>
</ul>
<h2 id="调试相关"><a href="#调试相关" class="headerlink" title="调试相关"></a>调试相关</h2><p>GDB 使用</p>
<p>内存泄漏</p>
<h4 id="COREDUMP-调试"><a href="#COREDUMP-调试" class="headerlink" title="COREDUMP 调试"></a>COREDUMP 调试</h4><p>终止时产生 Coredump 文件，默认为 core 可以 echo “pattern” core_pattern 更改命名规则。</p>
<p>死锁？发个 kill -3 pid 或者 kill -s SIGQUIT pid 产生 core</p>
<p>然后 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb -c ./a.out ./core</span><br><span class="line">gdb bt	// backtrace 查看调用栈</span><br><span class="line">或者</span><br><span class="line">gdb info stack // 显示变量信息</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">pstack pid 看进程信息</span><br></pre></td></tr></table></figure>



<h4 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h4><h2 id="C-并发编程"><a href="#C-并发编程" class="headerlink" title="C++ 并发编程"></a>C++ 并发编程</h2><h4 id="unique-lock-vs-lock-guard-vs-scope-lock"><a href="#unique-lock-vs-lock-guard-vs-scope-lock" class="headerlink" title="unique_lock vs lock_guard vs scope_lock"></a>unique_lock vs lock_guard vs scope_lock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能传入 std::adopt_lock</span></span><br><span class="line"><span class="comment">// 没有 lock，unlock 方法</span></span><br><span class="line"><span class="built_in">lock_guard</span> (mutex_type&amp; m, <span class="type">adopt_lock_t</span> tag);</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">unique_lock</span>(mutex_type&amp; m, <span class="type">defer_lock_t</span> t); <span class="comment">// 延迟上锁</span></span><br><span class="line"><span class="built_in">unique_lock</span>(mutex_type&amp; m, adopt_lock t);	</span><br><span class="line"><span class="built_in">unique_lock</span>(mutex_type&amp; m, try_to_lock t); <span class="comment">// 非阻塞尝试上锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子性地上多个锁，可以避免死锁</span></span><br><span class="line">std::<span class="built_in">lock</span>(...)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// std::lock 的 c++ 17 版本</span></span><br><span class="line">std::<span class="built_in">scope_lock</span>(mutex...)</span><br></pre></td></tr></table></figure>





<h3 id="异步-Promise-future-packaged-task-async"><a href="#异步-Promise-future-packaged-task-async" class="headerlink" title="异步 Promise future packaged_task async"></a>异步 Promise future packaged_task async</h3><p><img src="https://zh-blog.logan.tw/static/images/2021/09/26/future-class-diagram.png" alt="std::future、std::promise、std::packaged_task 與 std::async 的關聯圖"></p>
<h3 id="C-协程"><a href="#C-协程" class="headerlink" title="C++协程"></a>C++协程</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>co_await 调用一个 awaiter 对象</p>
<p>co_yield 挂起一个协程</p>
<p>co_return 协程返回</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-19T11:07:00.000Z" title="11/19/2024, 7:07:00 PM">2024-11-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-11-20T15:06:51.481Z" title="11/20/2024, 11:06:51 PM">2024-11-20</time></span><span class="level-item"><a class="link-muted" href="/categories/Test/">Test</a></span><span class="level-item">a few seconds read (About 1 word)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/11/19/testCat/">testCat</a></p><div class="content"><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/148c44918f3f598353e53f32a30e6089?s=128" alt="Chord"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Chord</p><p class="is-size-6 is-block">Junior SDE, NJUer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/chord2048" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/chord2048"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Photo/"><span class="level-start"><span class="level-item">Photo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Test/"><span class="level-start"><span class="level-item">Test</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-11-20T15:06:51.481Z">2024-11-20</time></p><p class="title"><a href="/2024/11/20/Baobao/">饱的照片</a></p><p class="categories"><a href="/categories/Photo/">Photo</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-11-20T15:06:51.481Z">2024-11-20</time></p><p class="title"><a href="/2024/11/20/hello-world/">Hello World</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-11-20T15:06:51.481Z">2024-11-20</time></p><p class="title"><a href="/2024/11/20/testImg/">TestPhoto</a></p><p class="categories"><a href="/categories/Photo/">Photo</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-11-20T15:06:51.481Z">2024-11-20</time></p><p class="title"><a href="/2024/11/20/C++%E5%85%AB%E8%82%A1%E6%96%87/">Hello World</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-11-19T11:07:00.000Z">2024-11-19</time></p><p class="title"><a href="/2024/11/19/testCat/">testCat</a></p><p class="categories"><a href="/categories/Test/">Test</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/chord_logo.svg" alt="Rat Rat" height="28"></a><p class="is-size-7"><span>&copy; 2024 Chord</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2024</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>